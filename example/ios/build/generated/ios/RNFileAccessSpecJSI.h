/**
 * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
 *
 * Do not edit this file as changes may cause incorrect behavior and will be lost
 * once the code is regenerated.
 *
 * @generated by codegen project: GenerateModuleH.js
 */

#pragma once

#include <ReactCommon/TurboModule.h>
#include <react/bridging/Bridging.h>

namespace facebook::react {


  
#pragma mark - NativeFileAccessFileStat

template <typename P0, typename P1, typename P2, typename P3, typename P4>
struct NativeFileAccessFileStat {
  P0 filename;
  P1 lastModified;
  P2 path;
  P3 size;
  P4 type;
  bool operator==(const NativeFileAccessFileStat &other) const {
    return filename == other.filename && lastModified == other.lastModified && path == other.path && size == other.size && type == other.type;
  }
};

template <typename T>
struct NativeFileAccessFileStatBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.filename)>(rt, value.getProperty(rt, "filename"), jsInvoker),
      bridging::fromJs<decltype(types.lastModified)>(rt, value.getProperty(rt, "lastModified"), jsInvoker),
      bridging::fromJs<decltype(types.path)>(rt, value.getProperty(rt, "path"), jsInvoker),
      bridging::fromJs<decltype(types.size)>(rt, value.getProperty(rt, "size"), jsInvoker),
      bridging::fromJs<decltype(types.type)>(rt, value.getProperty(rt, "type"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String filenameToJs(jsi::Runtime &rt, decltype(types.filename) value) {
    return bridging::toJs(rt, value);
  }

  static double lastModifiedToJs(jsi::Runtime &rt, decltype(types.lastModified) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String pathToJs(jsi::Runtime &rt, decltype(types.path) value) {
    return bridging::toJs(rt, value);
  }

  static double sizeToJs(jsi::Runtime &rt, decltype(types.size) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String typeToJs(jsi::Runtime &rt, decltype(types.type) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "filename", bridging::toJs(rt, value.filename, jsInvoker));
    result.setProperty(rt, "lastModified", bridging::toJs(rt, value.lastModified, jsInvoker));
    result.setProperty(rt, "path", bridging::toJs(rt, value.path, jsInvoker));
    result.setProperty(rt, "size", bridging::toJs(rt, value.size, jsInvoker));
    result.setProperty(rt, "type", bridging::toJs(rt, value.type, jsInvoker));
    return result;
  }
};



#pragma mark - NativeFileAccessFsStat

template <typename P0, typename P1, typename P2, typename P3>
struct NativeFileAccessFsStat {
  P0 internal_free;
  P1 internal_total;
  P2 external_free;
  P3 external_total;
  bool operator==(const NativeFileAccessFsStat &other) const {
    return internal_free == other.internal_free && internal_total == other.internal_total && external_free == other.external_free && external_total == other.external_total;
  }
};

template <typename T>
struct NativeFileAccessFsStatBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.internal_free)>(rt, value.getProperty(rt, "internal_free"), jsInvoker),
      bridging::fromJs<decltype(types.internal_total)>(rt, value.getProperty(rt, "internal_total"), jsInvoker),
      bridging::fromJs<decltype(types.external_free)>(rt, value.getProperty(rt, "external_free"), jsInvoker),
      bridging::fromJs<decltype(types.external_total)>(rt, value.getProperty(rt, "external_total"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static double internal_freeToJs(jsi::Runtime &rt, decltype(types.internal_free) value) {
    return bridging::toJs(rt, value);
  }

  static double internal_totalToJs(jsi::Runtime &rt, decltype(types.internal_total) value) {
    return bridging::toJs(rt, value);
  }

  static double external_freeToJs(jsi::Runtime &rt, decltype(types.external_free) value) {
    return bridging::toJs(rt, value);
  }

  static double external_totalToJs(jsi::Runtime &rt, decltype(types.external_total) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "internal_free", bridging::toJs(rt, value.internal_free, jsInvoker));
    result.setProperty(rt, "internal_total", bridging::toJs(rt, value.internal_total, jsInvoker));
    if (value.external_free) {
      result.setProperty(rt, "external_free", bridging::toJs(rt, value.external_free.value(), jsInvoker));
    }
    if (value.external_total) {
      result.setProperty(rt, "external_total", bridging::toJs(rt, value.external_total.value(), jsInvoker));
    }
    return result;
  }
};

class JSI_EXPORT NativeFileAccessCxxSpecJSI : public TurboModule {
protected:
  NativeFileAccessCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void addListener(jsi::Runtime &rt, jsi::String eventType) = 0;
  virtual void removeListeners(jsi::Runtime &rt, double count) = 0;
  virtual jsi::Value appendFile(jsi::Runtime &rt, jsi::String path, jsi::String data, jsi::String encoding) = 0;
  virtual jsi::Value cancelFetch(jsi::Runtime &rt, double requestId) = 0;
  virtual jsi::Value concatFiles(jsi::Runtime &rt, jsi::String source, jsi::String target) = 0;
  virtual jsi::Value cp(jsi::Runtime &rt, jsi::String source, jsi::String target) = 0;
  virtual jsi::Value cpAsset(jsi::Runtime &rt, jsi::String asset, jsi::String target, jsi::String type) = 0;
  virtual jsi::Value cpExternal(jsi::Runtime &rt, jsi::String source, jsi::String targetName, jsi::String dir) = 0;
  virtual jsi::Value df(jsi::Runtime &rt) = 0;
  virtual jsi::Value exists(jsi::Runtime &rt, jsi::String path) = 0;
  virtual void fetch(jsi::Runtime &rt, double requestId, jsi::String resource, jsi::Object init) = 0;
  virtual jsi::Value getAppGroupDir(jsi::Runtime &rt, jsi::String groupName) = 0;
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual jsi::Value hash(jsi::Runtime &rt, jsi::String path, jsi::String algorithm) = 0;
  virtual jsi::Value isDir(jsi::Runtime &rt, jsi::String path) = 0;
  virtual jsi::Value ls(jsi::Runtime &rt, jsi::String path) = 0;
  virtual jsi::Value mkdir(jsi::Runtime &rt, jsi::String path) = 0;
  virtual jsi::Value mv(jsi::Runtime &rt, jsi::String source, jsi::String target) = 0;
  virtual jsi::Value readFile(jsi::Runtime &rt, jsi::String path, jsi::String encoding) = 0;
  virtual jsi::Value readFileChunk(jsi::Runtime &rt, jsi::String path, double offset, double length, jsi::String encoding) = 0;
  virtual jsi::Value stat(jsi::Runtime &rt, jsi::String path) = 0;
  virtual jsi::Value statDir(jsi::Runtime &rt, jsi::String path) = 0;
  virtual jsi::Value unlink(jsi::Runtime &rt, jsi::String path) = 0;
  virtual jsi::Value unzip(jsi::Runtime &rt, jsi::String source, jsi::String target) = 0;
  virtual jsi::Value writeFile(jsi::Runtime &rt, jsi::String path, jsi::String data, jsi::String encoding) = 0;

};

template <typename T>
class JSI_EXPORT NativeFileAccessCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = "FileAccess";

protected:
  NativeFileAccessCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeFileAccessCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeFileAccessCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeFileAccessCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    void addListener(jsi::Runtime &rt, jsi::String eventType) override {
      static_assert(
          bridging::getParameterCount(&T::addListener) == 2,
          "Expected addListener(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::addListener, jsInvoker_, instance_, std::move(eventType));
    }
    void removeListeners(jsi::Runtime &rt, double count) override {
      static_assert(
          bridging::getParameterCount(&T::removeListeners) == 2,
          "Expected removeListeners(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::removeListeners, jsInvoker_, instance_, std::move(count));
    }
    jsi::Value appendFile(jsi::Runtime &rt, jsi::String path, jsi::String data, jsi::String encoding) override {
      static_assert(
          bridging::getParameterCount(&T::appendFile) == 4,
          "Expected appendFile(...) to have 4 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::appendFile, jsInvoker_, instance_, std::move(path), std::move(data), std::move(encoding));
    }
    jsi::Value cancelFetch(jsi::Runtime &rt, double requestId) override {
      static_assert(
          bridging::getParameterCount(&T::cancelFetch) == 2,
          "Expected cancelFetch(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::cancelFetch, jsInvoker_, instance_, std::move(requestId));
    }
    jsi::Value concatFiles(jsi::Runtime &rt, jsi::String source, jsi::String target) override {
      static_assert(
          bridging::getParameterCount(&T::concatFiles) == 3,
          "Expected concatFiles(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::concatFiles, jsInvoker_, instance_, std::move(source), std::move(target));
    }
    jsi::Value cp(jsi::Runtime &rt, jsi::String source, jsi::String target) override {
      static_assert(
          bridging::getParameterCount(&T::cp) == 3,
          "Expected cp(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::cp, jsInvoker_, instance_, std::move(source), std::move(target));
    }
    jsi::Value cpAsset(jsi::Runtime &rt, jsi::String asset, jsi::String target, jsi::String type) override {
      static_assert(
          bridging::getParameterCount(&T::cpAsset) == 4,
          "Expected cpAsset(...) to have 4 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::cpAsset, jsInvoker_, instance_, std::move(asset), std::move(target), std::move(type));
    }
    jsi::Value cpExternal(jsi::Runtime &rt, jsi::String source, jsi::String targetName, jsi::String dir) override {
      static_assert(
          bridging::getParameterCount(&T::cpExternal) == 4,
          "Expected cpExternal(...) to have 4 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::cpExternal, jsInvoker_, instance_, std::move(source), std::move(targetName), std::move(dir));
    }
    jsi::Value df(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::df) == 1,
          "Expected df(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::df, jsInvoker_, instance_);
    }
    jsi::Value exists(jsi::Runtime &rt, jsi::String path) override {
      static_assert(
          bridging::getParameterCount(&T::exists) == 2,
          "Expected exists(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::exists, jsInvoker_, instance_, std::move(path));
    }
    void fetch(jsi::Runtime &rt, double requestId, jsi::String resource, jsi::Object init) override {
      static_assert(
          bridging::getParameterCount(&T::fetch) == 4,
          "Expected fetch(...) to have 4 parameters");

      return bridging::callFromJs<void>(
          rt, &T::fetch, jsInvoker_, instance_, std::move(requestId), std::move(resource), std::move(init));
    }
    jsi::Value getAppGroupDir(jsi::Runtime &rt, jsi::String groupName) override {
      static_assert(
          bridging::getParameterCount(&T::getAppGroupDir) == 2,
          "Expected getAppGroupDir(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getAppGroupDir, jsInvoker_, instance_, std::move(groupName));
    }
    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    jsi::Value hash(jsi::Runtime &rt, jsi::String path, jsi::String algorithm) override {
      static_assert(
          bridging::getParameterCount(&T::hash) == 3,
          "Expected hash(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::hash, jsInvoker_, instance_, std::move(path), std::move(algorithm));
    }
    jsi::Value isDir(jsi::Runtime &rt, jsi::String path) override {
      static_assert(
          bridging::getParameterCount(&T::isDir) == 2,
          "Expected isDir(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::isDir, jsInvoker_, instance_, std::move(path));
    }
    jsi::Value ls(jsi::Runtime &rt, jsi::String path) override {
      static_assert(
          bridging::getParameterCount(&T::ls) == 2,
          "Expected ls(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::ls, jsInvoker_, instance_, std::move(path));
    }
    jsi::Value mkdir(jsi::Runtime &rt, jsi::String path) override {
      static_assert(
          bridging::getParameterCount(&T::mkdir) == 2,
          "Expected mkdir(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::mkdir, jsInvoker_, instance_, std::move(path));
    }
    jsi::Value mv(jsi::Runtime &rt, jsi::String source, jsi::String target) override {
      static_assert(
          bridging::getParameterCount(&T::mv) == 3,
          "Expected mv(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::mv, jsInvoker_, instance_, std::move(source), std::move(target));
    }
    jsi::Value readFile(jsi::Runtime &rt, jsi::String path, jsi::String encoding) override {
      static_assert(
          bridging::getParameterCount(&T::readFile) == 3,
          "Expected readFile(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::readFile, jsInvoker_, instance_, std::move(path), std::move(encoding));
    }
    jsi::Value readFileChunk(jsi::Runtime &rt, jsi::String path, double offset, double length, jsi::String encoding) override {
      static_assert(
          bridging::getParameterCount(&T::readFileChunk) == 5,
          "Expected readFileChunk(...) to have 5 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::readFileChunk, jsInvoker_, instance_, std::move(path), std::move(offset), std::move(length), std::move(encoding));
    }
    jsi::Value stat(jsi::Runtime &rt, jsi::String path) override {
      static_assert(
          bridging::getParameterCount(&T::stat) == 2,
          "Expected stat(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::stat, jsInvoker_, instance_, std::move(path));
    }
    jsi::Value statDir(jsi::Runtime &rt, jsi::String path) override {
      static_assert(
          bridging::getParameterCount(&T::statDir) == 2,
          "Expected statDir(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::statDir, jsInvoker_, instance_, std::move(path));
    }
    jsi::Value unlink(jsi::Runtime &rt, jsi::String path) override {
      static_assert(
          bridging::getParameterCount(&T::unlink) == 2,
          "Expected unlink(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::unlink, jsInvoker_, instance_, std::move(path));
    }
    jsi::Value unzip(jsi::Runtime &rt, jsi::String source, jsi::String target) override {
      static_assert(
          bridging::getParameterCount(&T::unzip) == 3,
          "Expected unzip(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::unzip, jsInvoker_, instance_, std::move(source), std::move(target));
    }
    jsi::Value writeFile(jsi::Runtime &rt, jsi::String path, jsi::String data, jsi::String encoding) override {
      static_assert(
          bridging::getParameterCount(&T::writeFile) == 4,
          "Expected writeFile(...) to have 4 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::writeFile, jsInvoker_, instance_, std::move(path), std::move(data), std::move(encoding));
    }

  private:
    friend class NativeFileAccessCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};

} // namespace facebook::react
